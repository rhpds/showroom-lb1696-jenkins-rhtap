== Chapter 2: Tightrope Walking without a Net

* As our story unfolds, you find yourself donning the hat of a QA engineer.
* The moment you receive an email from the *Quarkus* developer announcing the completion of his task, the baton is passed to you.
* It's now in your hands to validate the integrity and quality of the code delivered.

'''
=== Testing the Insecure Application

* Your first action is to deploy the image, built by the developer, to the *QA environment*.
* Your experience as a QA engineer has equipped you with a toolkit of scripts, designed to automate such tasks.
* You open your terminal, and type the command:

[source, role="execute"]
----
./deploy-app.sh insecured
----

* As soon as the script completes its run and the application is deployed, you proceed to copy the application's URL and paste it in your browser, eager to start testing the application.

NOTE: It may take the application a few minutes to start after the script completes.

image::29_Deploy_Insecure_Application.png[]

* You switch back to **RHDH** and select the **Topology** view tab."

* You click the route linked to the **insecured-app** pod to open the application in a new browser tab.

image::128_insecureapp_Topology_View.png[]

* But, oh no!
* To your disbelief, the application has been compromised, now infected with a ransomware virus.
* How could this have possibly happened?

image::31_Ransomeware.png[]

* Without wasting a moment, you recognize the severity of the situation and quickly report the issue to your organization's security team, urging them to launch an investigation into this critical breach.

'''

=== Installing the Guard Rails

* In the aftermath of discovering a critical vulnerability during QA testing, the organization convenes a post-mortem to establish a more secure development process. 

* You, a Red Hat consultant with expertise in supply chain security, join the meeting alongside the developers, QA engineers, platform engineers, and security leads.

* You begin by addressing the group: "Thank you for having me. I understand that a malicious component slipped through into your QA environment."

* The *QA engineer* nods in agreement: "Yes, I ran my usual tests, but the application turned out to be compromised. I was shocked and immediately reported the issue to our security team."

* The *security engineer* adds: "We isolated the environment and reviewed logs and build artifacts. It appears the culprit was an unverified library that made it into our pipeline."

* "Right," you reply. "In scenarios like this, it’s often not one person’s fault, but a gap in the controls we put in place. We need to strengthen your software supply chain in a way that prevents these incidents from happening again. Let me walk you through the key security practices we will put in place."

=== 1. Signed Commits

* "For starters, let’s make sure all source code commits are cryptographically signed. This gives us provenance, we can verify who made a change and whether that change is authentic."
* *Developer*: "So you’re saying even if I didn’t see anything malicious, unsigned commits could let unverified code in?"
* "Exactly. We will configure your Git environment to enforce signed commits. That way, only authorized and verified changes can enter your build process."

=== 2. Signed Container Images

* "Next, we will confirm that the images built from your verified code are also signed, so no unsigned or tampered image can be deployed," you say.
* "We will use link:glossary.html#cosign[*Cosign*,window=_blank] to create a signing secret," you explain, as you run the command in the terminal:

[source, role="execute"]
----
COSIGN_PASSWORD=openshift cosign generate-key-pair k8s://openshift-pipelines/signing-secrets
----

image::76_Cosign_Secret.png[]

* After generating the key pair, run this script to store the Cosign secrets in Vault so that our software templates can use them when needed."

[source, role="execute"]
----
./create-vault-entries.sh
----

image::105_copy_secret_to_vault.png[]

* "Finally, we need to set up **Cosign** to use our **TUF mirror registry**, which provides the cryptographic keys and trust information required for **Cosign** to sign our software artifacts," you explain, as you run the following command in the terminal:

[source, role="execute", subs="attributes"]
----
cosign initialize --mirror=https://tuf-trusted-artifact-signer.{openshift_cluster_ingress_domain} --root=https://tuf-trusted-artifact-signer.{openshift_cluster_ingress_domain}/root.json
----

image::78_Initialize_Cosign.png[]

=== 3. Generating Software Bill of Materials (SBOM)

* "We'll go a step further and create an attested *Software Bill of Materials (SBOM)*."
* *Developer*: "What is an *SBOM*?"
* "Think of an *SBOM* as a complete list of ingredients in your application. It details all the open-source components and dependencies used to build your software," you explain.
* *Developer*: "How does that help with Security?"
* "Excellent question!  Having an *SBOM* with attestation is crucial. Let's say a known vulnerability is discovered in one of the open-source components used in your application."
* "With an attested *SBOM*, you can quickly identify which versions of your application are affected and prioritize patching. *Attestation* ensures the *SBOM* itself hasn't been tampered with, providing confidence in its accuracy." you add.

=== 4. Vulnerability Scanning and Policy Enforcement

* *Security Engineer*:  "Okay, but how can we enforce policies that stop the deployment of images with known malicious libraries?"
* "Ah, yes. I remember that you struggled quite a bit with the link:https://en.wikipedia.org/wiki/Log4Shell[*Log4Shell*,window=_blank] vulnerability a few years back."
* "We will include steps in the pipeline to perform both image scans and image checks against known CVEs and your organization's policies. This way, we ensure that the images are clear of known vulnerabilities and that our policies are enforced during the build and deployment stages," you answer.
* "In fact, let me log in to link:glossary.html#acs[*Red Hat Advanced Cluster Security (ACS)*,window=_blank] now and show you what those policies look like," you say as you open the ACS Console using this https://central-stackrox.{OPENSHIFT_CLUSTER_INGRESS_DOMAIN}[*URL*,window=_blank] and log in with your credentials, **username**: {adminuser} and **password**: {password}.

image::80_rhacs_login.png[]

* You expand the *Platform Configuration* list from the left menu and then click on the *Policy Management* link, saying: "Here you can find a list of readily available policies."

image::83_rhacs_policy_management.png[]

* "For example, this policy checks if your image has the infamous *Log4Shell* vulnerability," you explain as you scroll down to show the *Log4Shell* policy.

TIP: You can filter by Policy and enter the policy name “Log4Shell” to find it more quickly.

image::106_Filter_Log4Shell.png[]

* You click on the *Kebab menu icon* next to this policy, and then click on *Edit policy*, adding: "We can modify the behavior of this policy if we want."

image::84_rhacs_edit_policy.png[]

* "Let’s click on *Policy Behavior*, Here, we can choose whether we want **ACS** to block the build or deployment if the policy is violated, or simply trigger an alert."
* "For example, if we click on the **Review** section, we can see that this policy is configured to raise an alert if **Log4Shell** is detected during the build or deploy process."

image::107_Policy_Behavior.png[]

* "We can also configure new policies. Let's' set up a policy that verifies that our container image is signed during the build stage and whenever we attempt to deploy an application to *OpenShift*," you say as you click on the *Integrations* link in the left menu.

image::81_rhacs_integrations.png[]

* You scroll down to *Signature Integrations* and click on the *Signature* tile.

image::82_rhacs_signature_integrations.png[]

* You click on the *New Integration* button as you say: "This policy requires *ACS* to integrate with *Cosign* for this check."

image::85_rhacs_new_integration.png[]

* We'll need the secret that we created earlier for this step, in your terminal run the following command and copy the content of cosign.pub

[source, role="execute"]
----
cat cosign.pub 
----

image::108_cat_cosign_pub.png[]

* You begin configuring the new integration as follows:
. You enter *cosign* for the *Integration name*,
. You then expand the *Cosign public keys* field and click on *Add new public key*, to set the *Public key name* as cosign.pub,
. and for the *Public key value* you use the public key you just copied from the terminal
. Finally, you click the *Save* button.

image::86_configure_new_integration.png[]

NOTE: For convenience, there is already a policy in ACS called *0-Trusted Signature Policy* that checks an image for a valid signature.

* "All we need to do is enable the policy *0-Trusted Signature Policy* and configure it to use the *cosign integration* we just created," you explain to the team as you enable the policy.

. You select *Policy Management* from the left menu.

image::rhacs-policy-management.png[]

. You find the policy called *0-Trusted Signature Policy* at the top of the list.

image::rhacs-policy-management-list.png[]

. You click the *Kebab menu icon* next to the policy and select *Edit policy*.

image::109_edit_policy.png[]

. You then select *Rules* and click the *Select* button.

image::rhacs-policy-criteria-select.png[]

"This is where we configure our policy to use the *cosign integration* we just created," you explain to the team as you select the cosign signature integration and click the *Save* button.

image::rhacs-policy-criteria-trusted-image-signers.png[]

. You continue clicking next at the bottom until you finally save the policy.
. "Now that the policy is updated, we want to enable it," you say as you click the *Kebab menu icon* again for the same policy and select *Enable policy*.

image::110_enable_policy.png[]

* "All done. ACS will now enforce this policy in the build stage of our application."
* *Security Engineer*:  "That sounds comprehensive. Implementing these measures will definitely strengthen our security posture."
* "Excellent. Let me prepare the necessary setup and then I will demonstrate our solution based on link:glossary.html#rhtap[*Red Hat Trusted Application Pipeline (RHTAP)*,window=_blank] in action."
* "*RHTAP* provides prebuilt pipelines with automated security checks, aiming to achieve the highest level of security, link:glossary.html#slsa[*SLSA*,window=_blank] Level 3, for built artifacts and offers the capabilities I just explained."

=== Chapter 2 - Summary

As the baton passed to the QA engineer for testing, the story took a dramatic turn. The deployed application, instead of showcasing the fruits of their labor, revealed a critical vulnerability, it was infected with ransomware. This revelation abruptly interrupted the testing process and cast a shadow over the software supply chain's security, sparking concerns about vulnerability and exposure.

The next chapter of our story will showcase *Red Hat Trusted Application Pipeline (RHTAP)* in action. We will explore how integrating these security measures into the build pipelines and deployment process can safeguard our software supply chain against the ever-present specter of cyber threats.