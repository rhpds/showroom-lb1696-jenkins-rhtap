
= Bonus Chapter: Securing a Quarkus Service Software Supply Chain (Tekton)

This bonus exercise follows the same journey you completed with the Jenkins based templates, however this time you will use **Tekton**, the cloud native engine that backs **OpenShift Pipelines**.  
The objective is identical, you will create build and deploy resources, sign all artifacts, generate an SBOM, and let **Red Hat Advanced Cluster Security (ACS)** enforce your policies.  
Along the way you will note the few places where a Tekton pipeline feels different from Jenkins.

'''

== 1. Launch the “Securing a Quarkus Service Software Supply Chain (Tekton)” template

. In the **Red Hat Developer Hub** catalog search for *Securing a Quarkus Service Software Supply Chain (Tekton)*.  
  image::120_select_tekton_template.png[]
. Click **Choose** then **Next** to open the parameter screen.  
  image::121_template_parameters.png[]
. Accept the default namespace, then click **Create**.  
  As before RHDH scaffolds a source repository, OpenShift resources, and a CI pipeline, but this time the pipeline is a **Tekton Pipeline** object rather than a Jenkins job.

'''

== 2. Examine the generated Tekton resources

. Switch to the OpenShift **Developer ➜ Pipelines** view and select the new pipeline named *quarkus‑svc‑supply‑chain*.  
  image::122_openshift_pipelines_list.png[]
. Notice the **Pipeline**, **Tasks**, and **PipelineRuns** custom resources.  
  In Jenkins you saw these stages inside Blue Ocean, here they are native Kubernetes objects that OpenShift renders in the console.

TIP: Tekton pipelines are defined as YAML and stored with your source just like application code.  This enables pull‑request reviews and Git history for the CI definition itself.

'''

== 3. Trigger the pipeline

. In the **Pipeline** details click **Start**, accept the defaults, and press **Start** again.  
  OpenShift immediately creates a **PipelineRun** and one **TaskRun** per step.  
  image::123_start_pipeline_run.png[]
. Follow the live logs directly in the console.  
  You will recognise the same stages you saw in Jenkins, for example *Clone Repository*, *Build Image*, *Sign Image*, and *Generate SBOM*.

Key difference:  
* Jenkins streamed logs from a single pod while Tekton creates a fresh pod for each **TaskRun**.  This improves isolation and lets Kubernetes schedule each step independently.

'''

== 4. Publishing Cosign keys to Vault

The template already generated a `cosign.pub` and private key in the *signing‑secrets* Kubernetes secret, the same as the Jenkins variant.

. Run the helper script in the development terminal to copy the keys to Vault  
+
[source,role="execute"]
----
./create-vault-entries.sh
----
. Verify that the Vault path now holds both `cosign.pub` and `cosign.key`.  
  image::124_vault_keys.png[]

No changes are required here, Tekton and Jenkins both refer to the same secret when they sign images.

'''

== 5. Verifying the SBOM and signatures

. After the **PipelineRun** completes, expand the *Generate SBOM* task and download `bom.cdx.json`.  
  image::125_task_generate_sbom.png[]
. Upload the SBOM to Dependency‑Track as shown in Chapter 2.  
  The value is identical, centralized visibility, continuous CVE watch, and audit evidence.

'''

== 6. ACS policy enforcement remains identical

Because the container registry, cosign public key, and ACS policies are cluster wide, no additional ACS configuration is needed for the Tekton pipeline.

. Deploy the resulting image to QA.  
  ACS verifies the cosign signature and the SBOM attestation.  
  image::126_acs_violation_check.png[]
. Confirm the deployment turns green, showing that the trusted supply chain passed every gate.

'''

== Chapter Summary

You have now secured a Quarkus service using two different CI engines.

* **Jenkins** integrates with RHDH through a classic job and Blue Ocean view.  
* **Tekton** delivers the same stages as native Kubernetes custom resources that appear in the OpenShift Pipelines console.

Every downstream step, from cosign signatures, to SBOM generation, to ACS policy enforcement, remains unchanged, proving that the security controls you built are portable across pipeline tooling.
