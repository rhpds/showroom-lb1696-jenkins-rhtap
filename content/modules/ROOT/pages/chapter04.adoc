
= Bonus Lab: Building a Trusted Pipeline with OpenShift Pipelines and Tekton

* This bonus lab follows the same journey you completed with Secure Software Template, however this time you will use **Tekton**, the cloud native engine that backs **OpenShift Pipelines** instead of Jenkins.  

* The steps are identical, you will create build and deploy resources, sign all artifacts, generate an SBOM, and let **Red Hat Advanced Cluster Security (ACS)** enforce your policies.  

* Along the way you will notice the key places where a Tekton pipeline differs from Jenkins, thanks to the Tekton plugin’s tighter integration with Red Hat security tools.

'''

== 1. Launch the “Securing a Quarkus Service Software Supply Chain (Tekton)” template

* "Before we launch the new software template, let’s configure *Tekton Chains* to sign our container images," you explain, as you enter the following command in the terminal:

[source, role="execute"]
----
cd
cat <<EOF >> tekton-config.yaml
apiVersion: operator.tekton.dev/v1alpha1
kind: TektonConfig
metadata:
  name: config
spec:
  addon: {}
  chain:
    artifacts.oci.storage: oci
    artifacts.taskrun.format: in-toto
    artifacts.taskrun.storage: oci
    artifacts.pipelinerun.format: in-toto
    artifacts.pipelinerun.storage: oci
    transparency.enabled: true
    transparency.url: http://rekor-server.trusted-artifact-signer.svc
  config: {}
EOF
oc patch TektonConfig config --type='merge' --patch "$(cat tekton-config.yaml)"
----

* With Tekton Chains now configured, you return to **Red Hat Developer Hub**, click **Create** in the left navigation menu, and select the *Securing a Quarkus Service Software Supply Chain (Tekton)* template.  

image::127_select_tekton_template.png[]

* As you step through the forms for the Tekton software template, you notice that they are identical to the Jenkins template. You accept the defaults and click **Create**.

* Once the software template completes execution, you click on the *Open Component in Catalog* link.

== 2. Update your code in OpenShift Dev Spaces and trigger the pipeline

* You launch your IDE by clicking on the *OpenShift Dev Spaces (VSCode)* link.

* *OpenShift Dev Spaces* then begins creating your workspace, just like before.

* After waiting a few minutes for *OpenShift Dev Spaces* to finish setting up your workspace, you start updating the documentation.

* You expand the docs folder and open the markdown file *index.md*.

* At the document's end, you add: "Secure Pipeline powered by OpenShift Pipelines and Tekton."

* You follow the same steps like before to sign your code. Click on the *Hamburger button* (three horizontal bars) on the top left of your screen and select *Terminal -> New Terminal*

run the following command to add your changes to staging:

[source, role="execute"]
----
git add .
----
* Run the next command to commit your changes:

[source, role="execute"]
----
git commit -m "Doc Update"
----

* You will again receive the error message that states *error opening browser: exec: "xdg-open": executable file not found in $PATH*.  
* Copy and paste the url into a new browser tab/window and hit enter.

image::90_Gitsign_Commit_Message.png[]

* The browser will prompt you for your credentials.  Enter `{user}` for the *username* and `{password}` for the *password*.

image::91_Gitsign_Credentials_Prompt.png[]

* You will then be redirected to another page that will present a verification code.  Copy this code into your clipboard.

image::92_Gitsign_Verification_Code.png[]

* Return to *Dev Spaces* and paste this code into the waiting prompt in the *VS Code* terminal.
+
[source, role="execute"]
----
Enter verification code:
----

* If successful, you should receive a successful commit message:

image::93_Gitsign_Commit_Signed.png[]

* Push the code to the repository with the below command:

[source, role="execute"]
----
git push
----

* This action sets the build pipeline based on OpenShift Pipelines into motion.
* You switch back to the *Developer Hub* and select the *CI tab* from the top menu, to show the team that pipeline execution is in progress.

image::49_Expand_Secure_Pipeline.png[]

==== Task 1: Verify Commit

* "Once again we start by ensuring the source code modifications were made by a trusted source," you explain.
* You then click on the task *verify-commit* and pull up the logs.

image::51_Click_On_Verify_Commit.png[]

* "Here in the log, you can see the user we used and the comment we provided when we made the last code change.”
* "The *verify-commit* task executes the command link:https://git-scm.com/book/en/v2/Git-Tools-Signing-Your-Work[*git verify-commit*,window=_blank] to verify that the signature is valid, before the pipeline moves to the next task." you point out.

image::52_Verify_Commit_Log.png[]

==== Task 2: Scan Source

* "Then we run a static code analysis using *SonarQube* as we did in the Jenkins Pipeline. 

image::53_Scan_Source_Task.png[]

=== Task 3: Build and Sign Image

* "Similar to the Jenkins pipeline, the *build-sign-image* task is responsible for building a container image based on your verified source code. It then generates the *Software Bill of Materials (SBOM)* and pushes it to our *Red Hat Quay* registry upon successful completion of this task," you explain.

image::56_Build_Sign_Image.png[]

=== Task 4: Image Scan

* "Let's switch back to our pipeline view in *RHDH*, and look at the tasks performed by link:glossary.html#acs[*Red Hat Advanced Cluster Security (ACS)*,window=_blank]," you suggest.
* "The *acs-image-scan* task performs an image scan to identify known vulnerabilities within the container image. It compares the image components against known vulnerability databases, uncovering any CVEs (Common Vulnerabilities and Exposures) that might compromise the container."

image::60_ACS_Image_Scan_Task.png[]

* You notice not only that the Tekton pipeline is more visually clear, but also that, thanks to its deep integration with other Red Hat components, you can access reports in a much more seamless manner.
* "We can review the report generated by *ACS*." you note, as you click on the *Output* icon under *ACTIONS*.

image::61_Click_Output.png[]

* "Here you can see that we have 3 critical vulnerabilities, but what's great is that we also receive recommendations to upgrade to the version where those vulnerabilities are addressed."

image::62_Image_Scan_Result.png[]

=== Task 5: ACS Image Check

* You switch back to the pipeline view as you explain: "*ACS* doesn't stop at scanning; it can also assess whether the image adheres to predefined rules by performing an image check".
* "The *image-scan-check* task evaluates the container image against policies and compliance standards. This includes not running as root, using approved base images, or avoiding prohibited software packages, for example."

image::63_ACS_Image_Check_Task.png[]

* "Once again, we can view the analysis results," you say, clicking on the *Output* icon under *ACTIONS* and then selecting the *Image Check* tab.
* "In this report, you can see all the violations that *ACS* detected and the recommended remediation actions."

image::64_Image_Check_Result.png[]

=== Task 6: Export SBOM

image::65_Scan_Export_SBOM_Task.png[]

* You then demonstrate how to access the generated *SBOM* by clicking the link that's readily available in your pipeline view.

image::57_SBOM_Link.png[]

* After you click you immediately see the generated SBOM.

image::66_SBOM.png[]

== 3. Deploy and Test the secured image built with Tekton pipeline

* You execute the following command to deploy the image built by the secure pipeline:

[source, role="execute"]
----
./deploy-app.sh secured
----

* You switch back to **RHDH**, navigate to the **Topology** view tab, and locate the deployed pod just as you did earlier.

* You click the route linked to the **secured-app** pod, which opens the application in a new browser tab.

image::125_Topology_View.png[]

* "As you can see, the application is up and ready for testing," you explain.  
* "What’s even more important is that the developer didn’t need to worry about the underlying CI/CD tooling. All they needed to know was that once they committed code, the pipeline would securely build, sign, and publish the image to the registry—enforcing every guardrail and policy the organization has put in place."

image::126_secured_app.png[]

== Chapter Summary

You have now secured a Quarkus service using two different CI engines.

* **Jenkins** integrates with RHDH through a classic CI engine. 
* **Tekton** delivers the same stages as native Kubernetes custom resources.

Every downstream step, from cosign signatures, to SBOM generation, to ACS policy enforcement, remains unchanged, proving that the security controls you built are portable across pipeline tooling.

Whether your teams prefer Jenkins for its plugin ecosystem or Tekton for its Kubernetes‑native workflow, the guardrails you implemented guarantee that every workload reaches production with the same cryptographic assurance, supply‑chain transparency, and policy‑driven compliance.
