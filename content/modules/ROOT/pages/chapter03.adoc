== Chapter 3:  Red Hat Trusted Application Pipeline to the Rescue

* In the final chapter of our story, you demonstrate to the team how the *Red Hat Trusted Application Pipeline (RHTAP)* and Red Hat security tools can effectively tackle their security concerns, equipping the organization with a *Trusted Software Supply Chain*.

'''

=== Demonstrating the Secure Build Process

* You switch to the *Red Hat Developer Hub (RHDH)* dashboard, ready to demonstrate the new *Software Template* with the security enhancements.
* You click *Create* in the left menu and then select the *Choose* button for the *Securing a Quarkus Service Software Supply Chain (Jenkins)* software template.

image::34_Run_Secure_GPT.png[]

* You keep the default values and click the *Next* button on the first two forms.
* Before you click the *Review* button on the third form, you show the team that *Verify Commits* is set to *enabled* in this form.
* This is because this *software template* is using the *Trusted Artifacts Signer* to verify that code commits are signed.

image::35_Review_Commits_Enabled.png[]

* You click the *Review* button.
* After quickly reviewing the summary and seeing that everything looks great, you proceed to click the *Create* button.

image::36_Create_Second_GPT.png[]

* The secure *software template* executes successfully, you seize this moment to explain the value of using *software template* in this scenario.
* "This environment," you explain, "is created with all the security guardrails we discussed. What's fantastic about *software templates* is that the enhancements in the security pipeline are entirely transparent to our developer. This means they won't impact how he codes or builds applications."

* "To trigger our secure build pipeline, let's open VSCode and make a small change to the documentation.", you say.

* You click on the *Open Component in Catalog* link.

image::111_secure_templated_completed.png[]

* You find and click on the *OpenShift Dev Spaces (VSCode)* link.

image::95_Click_Openshift_Devspaces.png[]

* *OpenShift Dev Spaces* then begins creating your workspace, just like before.

* After waiting a few minutes for *OpenShift Dev Spaces* to finish setting up your workspace, you're presented with your IDE.
* You click the button *Yes, I trust the authors*.

image::96_Trust_Authors.png[]

* "For the purpose of this demo, updating the documentation will be enough to trigger the new build pipeline", you explain.
* You expand the docs folder and open the markdown file *index.md*.
* At the document's end, you add: "Build pipeline integrated with security tools."

image::97_Index_Markdown_Updated.png[]

* You click on the *Hamburger button* (three horizontal bars) on the top left of your screen and select *Terminal -> New Terminal*

image::98_Terminal_Menu.png[]

* Before you start committing your code, you confirm the Gitsign git config.
* "As you see, our development environment has been configured for Gitsign", you explain.
* Run the below command on the *VS Code* terminal to view the Gitsign global git config:
+
[source, role="execute"]
----
git config --global --list
----

NOTE: You may need to allow paste functionality when prompted by the browser.

image::94_Gitsign_Git_Global_Config.png[]

* To begin commiting your code to the repository, run the following command to add your changes to staging:
+
[source, role="execute"]
----
git add .
----
* Run the next command to commit your changes:
+
[source, role="execute"]
----
git commit -m "Doc Update"
----
* You will notice that you receive an error message that states *error opening browser: exec: "xdg-open": executable file not found in $PATH*.  This is because our *VS Code* terminal is trying to open a browser window to obtain your credentials for signing but is unable to as it is running as a container.
* However, Gitsign allows you to provide your signing credentials by copying and pasting the url it outputs into a separate browser window.
* Copy and paste the url into a new browser tab/window and hit enter.

image::90_Gitsign_Commit_Message.png[]

* The browser will prompt you for your credentials.  Enter {user} for the username and {password} for the password.

image::91_Gitsign_Credentials_Prompt.png[]

* You will then be redirected to another page that will present a verification code.  Copy this code into your clipboard.

image::92_Gitsign_Verification_Code.png[]

* Return to *Dev Spaces* and paste this code into the waiting prompt in the *VS Code* terminal.
+
[source, role="execute"]
----
Enter verification code:
----
+
NOTE: Once you've pasted the code, depending on your browser, you may be presented with a popup to allow paste functionality in Devspaces.  Click *Allow* and then hit *Enter*.  If no popup appears, just hit *Enter*.

* If successful, you should receive a successful commit message:
+
image::93_Gitsign_Commit_Signed.png[]

* Push the code to the repository with the below command:
+
[source, role="execute"]
----
git push
----

* This action sets the build pipeline into motion.
* You switch back to the *Developer Hub* and select the *CI tab* from the top menu, to show the team that pipeline execution is in progress.

image::112_secure_pipeline_in_progress.png[]

TIP: You can view the pipeline in the *Blue Ocean* view in Jenkins just like you did before.

* You wait a few minutes until the build pipeline execution is complete, before you start explaining the security enhancements made to the build pipeline.
* "Remember the build process we used for the insecure application? We’ve now added seven new tasks to the pipeline, incorporating the security recommendations I outlined earlier."

image::113_Jenkins_Secure_Build_Pipeline.png[]

==== Task 1: Verify Commit

* "The first task after cloning our git repo, is ensuring the source code modifications were made by a trusted source," you explain.
* "This task will only succeed if it can verify a trusted signature on the last commit that triggered the pipeline. This is the signature we provided using *GitSign* when we committed the code from *Dev Spaces*."
* You then click on the task *verify-commit* and expand the logs section.

image::114_Jenkins_Click_On_Verify_Commit.png[]

* "Here in the log, you can see that we successfully validated the signature for the user who made the last code change.”
* "The *verify-commit* task executes the command link:https://git-scm.com/book/en/v2/Git-Tools-Signing-Your-Work[*git verify-commit*,window=_blank] to verify that the signature is valid, before the pipeline moves to the next task." you point out.

image::115_Jenkins__Verify_Commit_Log.png[]

==== Task 2: Scan Source

* "After we package the code, running a static analysis to detect any potential bugs or code style violations is a good idea."
* I've setup a task called *scan* task, we utilize a tool called link:https://www.sonarsource.com/products/sonarqube[*SonarQube*,window=_blank] to analyze the source code and provide reports based on its quality.
* "We can view the scan results from the pipeline logs as we did before, or we could log in to *SonarQube* to get an in-depth report."
* "Let's look at the *SonarQube* report this time," you decide.
* To access *SonarQube*, you use the following https://sonarqube-sonarqube.{OPENSHIFT_CLUSTER_INGRESS_DOMAIN}[*URL*,window=_blank]  and log in with your credentials, **username:** {adminuser} and **password**: {password}.
* You click on the project link in the *SonarQube* Dashboard.
* "Good news! Our application has passed the validation test by *SonarQube*," you observe.

image::54_SonarQube_Dashboard.png[]

=== Task 3: Build and Sign Image

* "Similar to your original pipeline, the *build-sign-image* task is responsible for building a container image based on your verified source code. It then attests the image and generates the *Software Bill of Materials (SBOM)* we discussed earlier."
* "This *SBOM* is then pushed to our *Red Hat Quay* registry upon successful completion of this task," you explain.
* "The SBOM is then stored in the image registry, alongside your container image.”

image::116_Jenkins_Build_Sign_Image.png[]

* You then switch to the image registry tab and point to the screen, showing that the generated attestation, signature, and SBOM files are sitting side-by-side with the resulting container image produced by the pipeline in the registry.

image::59_Generated_Artifacts_Registery.png[]

=== Task 4: Upload SBOM to Repository

* Once the *SBOM* has been generated, the next step is to upload it to your organization's CycloneDX repository. 
* "The *SBOM* now sits in a single catalogue that every team can query, storing each SBOM with its build number and signature gives auditors a clear trail that proves provenance, verifies licensing obligations, and shows when components were updated or removed," you explain.

image::119_Jenkins_Upload_SBOM_To_CycloneDX.png[]

=== Task 5: Upload SBOM to TPA

* In parallel, the *SBOM* is uploaded to Trusted Profile Analyzer (TPA).  We do this to turn the raw SBOM into actionable information.  For example, TPA can identify dependencies in your image that are targets of known Common Vulnerabilities and Exploits (CVEs).  These CVE's can be viewed on the Trusted Profile Analyzer console for the specific *SBOM* uploaded.

image::120_Jenkins_Upload_SBOM_To_TPA.png[]

* To access *Trusted Profile Analyzer (TPA)*, you use the following https://console-trusted-profile-analyzer.{OPENSHIFT_CLUSTER_INGRESS_DOMAIN}[*URL*,window=_blank] and log in with your credentials, **username**: {adminuser} and **password**: {password}.

* "You can view the vulnerabilities and recommended remediation inside the SBOM we just uploaded to **Trusted Profile Analyzer (TPA)**," you explain, clicking **Search** in the left navigation menu.

image::121_Search_TPA.png[]

* In the results table, click the **secured-app** link at the top. "The first entry in the list is the SBOM for our **secured-app** application," you point out.

image::122_Results_TPA.png[]

* You switch to the **Dependency Analytics Report** tab as ypu explain, "This view lists every discovered security issue and the remediation that Trusted Profile Analyzer suggests."

image::123_Dependency_Analytics_TPA.png[]

=== Task 6: ACS Image Check

* You switch back to the pipeline view as you explain: "*ACS* doesn't stop at scanning; it can also assess whether the image adheres to predefined rules by performing an image check".
* "The *image-scan-check* task evaluates the container image against policies and compliance standards. This includes not running as root, using approved base images, or avoiding prohibited software packages, for example."

image::118_Jenkins_ACS_Image_Check_Task.png[]

=== Task 7: Image Scan

* "The *acs-image-scan* task performs an image scan to identify known vulnerabilities within the container image. It compares the image components against known vulnerability databases, uncovering any CVEs (Common Vulnerabilities and Exposures) that might compromise the container."

image::117_Jenkins_ACS_Image_Scan_Task.png[]

=== Demonstrating the Secure Deploy Process

* Addressing the QA engineer, you begin, “Now, I'm going to show you how to validate that an image is signed before deploying it for testing.”
* “You'll use the link:glossary.html#ec[*Enterprise Contract CLI (ec)*,window=_blank] along with *Cosign* to first check the original image from the insecure application. I've prepared a script specifically for this purpose.”
* You execute the following command in the terminal:
+
[source, role="execute"]
----
./validate-image.sh insecured
----

image::67_Validate_Insecure_Image.png[]

* “As expected, the validation of this image failed. Now, let’s validate the secure image that we just built in the same way,” you indicate, and then you run the following command:
+
[source, role="execute"]
----
./validate-image.sh secured 
----

* "Obviously, the validation is successful with the secure image.” you conclude, pointing at the success result in the terminal.

image::79_EC_Validation_Success.png[]

* "We can also test our *0-Trusted Signature Policy*, by deploying both images to *OpenShift*, first we'll test the policy against the insecure image.
* You execute the following command to deploy the insecure image:
+
[source, role="execute"]
----
./deploy-app.sh insecured
----
* "The policy does its job and stops us from deploying the insecure application."

image::124_zero_trust_policy.png[]

* You then execute the  following command to deploy the image built by the secure pipeline:
+
[source, role="execute"]
----
./deploy-app.sh secured
----
* "This time the deployment is successful and you can proceed to test this application with confidence.", you assure the QA Engineer.

* You switch back to **RHDH** and select the **Topology** view tab, saying, "This view lets us visualize every pod deployed in our OpenShift project."

* You click the route linked to the **secured-app** pod to open the application in a new browser tab.

image::125_Topology_View.png[]

* "As you can see, the application is up, ready for testing, and fully protected by all the guardrails we added to our pipeline," you remark with confidence.

image::126_secured_app.png[]

=== Workshop - Summary

As we close the curtains on this workshop, it’s important to reflect on the journey we’ve embarked on together.
Throughout this experience, you've stepped into the shoes of developers, QA engineers, and security professionals, confronting head-on the hurdles that each role faces. More importantly, you've seen firsthand how the Red Hat Developer Hub (RHDH) and the Red Hat Trusted Application Pipeline (RHTAP) can transform these challenges into stepping stones for innovation and a solid foundation for building applications in a *Trusted Software Supply Chain*.
Thank you for joining us on this journey. May the knowledge you’ve gained empower you to become a beacon of innovation and security in your organization. Here's to your success in crafting a future built on innovation and security!

